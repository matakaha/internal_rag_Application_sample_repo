name: Deploy to Azure Web Apps

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: 'aci-runner-deployment'
  cancel-in-progress: false

env:
  RESOURCE_GROUP: 'rg-internal-rag-dev'
  WEBAPP_NAME: 'app-internal-rag-dev'
  VNET_NAME: 'vnet-internal-rag-dev'
  SUBNET_NAME: 'snet-container-instances'
  LOCATION: 'japaneast'
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

jobs:
  setup-runner:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      runner-name: ${{ steps.setup-runner.outputs.runner-name }}
      container-name: ${{ steps.setup-runner.outputs.container-name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Container Instance Runner
        id: setup-runner
        run: |
          # 動的なコンテナ名とRunner名を生成
          CONTAINER_GROUP_NAME="aci-runner-${{ github.run_id }}"
          RUNNER_NAME="runner-${{ github.run_id }}"
          echo "runner-name=$RUNNER_NAME" >> $GITHUB_OUTPUT
          echo "container-name=$CONTAINER_GROUP_NAME" >> $GITHUB_OUTPUT

          # GitHub Runner登録トークン取得
          RUNNER_TOKEN=$(curl -s -X POST \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token" \
            | jq -r .token)

          echo "RUNNER_TOKEN取得完了"

          # ACRのリソースIDを取得
          ACR_ID=$(az acr show --name acrinternalragdev --resource-group $RESOURCE_GROUP --query id -o tsv)
          
          # User Assigned Managed Identityを作成
          IDENTITY_NAME="id-aci-runner-${GITHUB_RUN_ID}"
          echo "Creating User Assigned Managed Identity..."
          az identity create \
            --name $IDENTITY_NAME \
            --resource-group $RESOURCE_GROUP \
            --location $LOCATION
          
          # IdentityのIDを取得
          IDENTITY_ID=$(az identity show \
            --name $IDENTITY_NAME \
            --resource-group $RESOURCE_GROUP \
            --query id -o tsv)
          
          IDENTITY_PRINCIPAL_ID=$(az identity show \
            --name $IDENTITY_NAME \
            --resource-group $RESOURCE_GROUP \
            --query principalId -o tsv)
          
          echo "Identity Principal ID: $IDENTITY_PRINCIPAL_ID"
          
          # Managed IdentityがEntra IDに伝播するまで待機
          echo "Waiting for Managed Identity to propagate to Entra ID..."
          sleep 60
          
          # IdentityにACR Pull権限を付与
          echo "Assigning AcrPull role to User Assigned Identity..."
          az role assignment create \
            --assignee $IDENTITY_PRINCIPAL_ID \
            --role AcrPull \
            --scope $ACR_ID
          
          # 権限の伝播を待つ
          echo "Waiting for role assignment to propagate..."
          sleep 30
          
          # User Assigned Managed Identityを使ってコンテナ作成
          # Private Endpoint経由でACRにアクセス(vNet内部通信)
          echo "Creating GitHub Runner container: $CONTAINER_GROUP_NAME"
          az container create \
            --resource-group $RESOURCE_GROUP \
            --name $CONTAINER_GROUP_NAME \
            --image acrinternalragdev.azurecr.io/github-runner:latest \
            --assign-identity $IDENTITY_ID \
            --acr-identity $IDENTITY_ID \
            --os-type Linux \
            --vnet $VNET_NAME \
            --subnet $SUBNET_NAME \
            --location $LOCATION \
            --cpu 2 \
            --memory 4 \
            --restart-policy Never \
            --environment-variables \
              GITHUB_REPOSITORY=${{ github.repository }} \
              RUNNER_REPOSITORY_URL=https://github.com/${{ github.repository }} \
              RUNNER_NAME=$RUNNER_NAME \
              RUNNER_TOKEN=$RUNNER_TOKEN \
              RUNNER_LABELS=self-hosted,azure,vnet \
              RUNNER_WORK_DIRECTORY=_work \
              GITHUB_TOKEN=${{ secrets.GH_PAT }}
          
          # ACIが起動するまで少し待機
          sleep 15

          # Runnerが登録されるまで待機
          echo "Waiting for runner to register with GitHub..."
          MAX_WAIT=300  # 最大5分待機
          ELAPSED=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            RUNNER_STATUS=$(curl -s \
              -H "Authorization: token ${{ secrets.GH_PAT }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runners" \
              | jq -r ".runners[] | select(.name==\"$RUNNER_NAME\") | .status")
            
            if [ "$RUNNER_STATUS" = "online" ]; then
              echo "Runner is online and ready!"
              break
            fi
            
            echo "Runner status: ${RUNNER_STATUS:-not found}. Waiting... ($ELAPSED/$MAX_WAIT seconds)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "Error: Runner did not come online within $MAX_WAIT seconds"
            exit 1
          fi

  build-and-deploy:
    needs: setup-runner
    runs-on: self-hosted
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (on self-hosted runner)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install dependencies
        working-directory: ./src
        run: |
          npm install

      - name: Build application
        working-directory: ./src
        run: |
          echo "Building Node.js application..."
          # ビルドが必要な場合はここに追加
          # npm run build

      - name: Package application
        run: |
          # wwwroot直下にsrcディレクトリが配置されるようにZIPを作成
          # -qオプションで静かに、-rで再帰的に、Linuxパス区切り文字(/)を保証
          cd src
          zip -r ../webapp.zip . -x "*.git*" -x "*node_modules/.cache/*"
          cd ..
          
          # ZIPの内容を確認
          echo "=== ZIP Contents ==="
          unzip -l webapp.zip | head -20

      - name: Diagnose Network and Authentication
        id: diagnose
        run: |
          echo "=== Network and Authentication Diagnostics ==="
          
          # 1. Azure認証確認
          echo "1. Checking Azure authentication..."
          az account show
          
          # 2. Web Appの情報取得
          echo "2. Getting Web App information..."
          az webapp show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.WEBAPP_NAME }} \
            --query "{name:name, state:state, hostNames:hostNames, httpsOnly:httpsOnly}" \
            -o json
          
          # 3. Web AppのネットワークVNet統合確認
          echo "3. Checking VNet integration..."
          VNET_INTEGRATION=$(az webapp vnet-integration list \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.WEBAPP_NAME }} \
            -o json 2>/dev/null || echo "[]")
          echo "$VNET_INTEGRATION"
          
          # 4. SCMエンドポイントへの接続性確認
          echo "4. Testing connectivity to SCM endpoint..."
          SCM_URL="https://${{ env.WEBAPP_NAME }}.scm.azurewebsites.net"
          echo "SCM URL: $SCM_URL"
          
          # curlで接続テスト（認証なし）
          SCM_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 "$SCM_URL" 2>&1 || echo "000")
          echo "SCM endpoint HTTP status: $SCM_RESPONSE"
          
          # 5. Web AppのPublic Network Access設定確認
          echo "5. Checking Public Network Access settings..."
          PUBLIC_ACCESS=$(az webapp show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.WEBAPP_NAME }} \
            --query "publicNetworkAccess" \
            -o tsv 2>/dev/null || echo "Enabled")
          echo "Public Network Access: $PUBLIC_ACCESS"
          
          # 6. Private Endpoint確認
          echo "6. Checking Private Endpoints..."
          PRIVATE_ENDPOINTS=$(az network private-endpoint list \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[?contains(name, 'app-internal-rag')].{name:name, provisioningState:provisioningState}" \
            -o json 2>/dev/null || echo "[]")
          echo "$PRIVATE_ENDPOINTS"
          
          # 7. NSG確認（Runner側のサブネット）
          echo "7. Checking NSG on runner subnet..."
          az network vnet subnet show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --name ${{ env.SUBNET_NAME }} \
            --query "{name:name, nsg:networkSecurityGroup.id}" \
            -o json
          
          # デプロイ方法を判定
          echo ""
          echo "=== Determining Deployment Method ==="
          
          # SCMエンドポイントにアクセス可能か判定
          if [ "$SCM_RESPONSE" = "401" ] || [ "$SCM_RESPONSE" = "403" ]; then
            # 401/403 = 認証エラー → SCMエンドポイントには到達可能
            echo "✅ SCM endpoint is accessible (authentication required)"
            echo "deploy_method=scm" >> $GITHUB_OUTPUT
          elif [ "$SCM_RESPONSE" = "000" ] || [ "$SCM_RESPONSE" = "timeout" ]; then
            # タイムアウトまたは接続不可 → Private Endpointまたは閉域
            echo "❌ SCM endpoint is NOT accessible (timeout/connection refused)"
            echo "deploy_method=arm" >> $GITHUB_OUTPUT
          else
            # その他のHTTPレスポンス
            echo "⚠️  SCM endpoint returned HTTP $SCM_RESPONSE"
            echo "deploy_method=arm" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to Azure Web Apps (SCM method)
        if: steps.diagnose.outputs.deploy_method == 'scm'
        run: |
          echo "=== Deploying via SCM endpoint (Kudu) ==="
          echo "SCM endpoint is accessible from this runner"
          
          # Get Publishing Credentials
          PUBLISH_CREDS=$(az webapp deployment list-publishing-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.WEBAPP_NAME }} \
            --query "{username:publishingUserName, password:publishingPassword}" \
            -o json)
          
          USERNAME=$(echo $PUBLISH_CREDS | jq -r .username)
          PASSWORD=$(echo $PUBLISH_CREDS | jq -r .password)
          
          # ZIP Deploy via SCM endpoint
          curl -X POST \
            -u "$USERNAME:$PASSWORD" \
            --data-binary @webapp.zip \
            "https://${{ env.WEBAPP_NAME }}.scm.azurewebsites.net/api/zipdeploy" \
            -H "Content-Type: application/zip" \
            --max-time 600
          
          echo "✅ Deployment via SCM completed"

      - name: Deploy to Azure Web Apps (ARM API method)
        if: steps.diagnose.outputs.deploy_method == 'arm'
        run: |
          echo "=== Deploying via Azure Resource Manager API (no SCM endpoint) ==="
          echo "SCM endpoint is NOT accessible - using ARM API instead"
          
          # Web AppのリソースIDを取得
          WEBAPP_RESOURCE_ID=$(az webapp show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.WEBAPP_NAME }} \
            --query id -o tsv)
          
          echo "Web App Resource ID: $WEBAPP_RESOURCE_ID"
          
          # アクセストークン取得（Federated Identity使用）
          ACCESS_TOKEN=$(az account get-access-token --resource https://management.azure.com --query accessToken -o tsv)
          
          # ZIP Deployエンドポイント（ARM API経由）
          DEPLOY_URL="https://management.azure.com${WEBAPP_RESOURCE_ID}/extensions/onedeploy?api-version=2022-03-01"
          
          echo "Deploy URL: $DEPLOY_URL"
          echo "Starting deployment via ARM API..."
          
          # Base64エンコードしたZIPファイルをJSON bodyとして送信
          ZIP_BASE64=$(base64 -w 0 webapp.zip)
          
          # JSON bodyを作成（echoでパイプ）
          echo "{\"properties\":{\"type\":\"zip\",\"packageUri\":\"data:application/zip;base64,${ZIP_BASE64}\"}}" > deploy-payload.json
          
          # ARM API経由でデプロイ実行
          DEPLOY_RESPONSE=$(curl -X PUT \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d @deploy-payload.json \
            "${DEPLOY_URL}" \
            --write-out "\nHTTP_STATUS:%{http_code}" \
            --max-time 600)
          
          HTTP_STATUS=$(echo "$DEPLOY_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response: $DEPLOY_RESPONSE"
          
          if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 201 ] || [ "$HTTP_STATUS" -eq 202 ]; then
            echo "✅ Deployment initiated successfully via ARM API"
          else
            echo "❌ Deployment failed with HTTP status: $HTTP_STATUS"
            exit 1
          fi
          
          # クリーンアップ
          rm -f deploy-payload.json

  cleanup:
    needs: [setup-runner, build-and-deploy]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    if: always()
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Remove Runner from GitHub
        continue-on-error: true
        run: |
          # Runner一覧取得(GitHub PATはSecretから直接取得)
          RUNNERS=$(curl -s \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runners")

          # 該当Runnerを削除
          RUNNER_ID=$(echo $RUNNERS | jq -r ".runners[] | select(.name==\"${{ needs.setup-runner.outputs.runner-name }}\") | .id")
          
          if [ ! -z "$RUNNER_ID" ]; then
            curl -X DELETE \
              -H "Authorization: token ${{ secrets.GH_PAT }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runners/$RUNNER_ID"
          fi

      - name: Cleanup Resources
        run: |
          CONTAINER_GROUP_NAME="${{ needs.setup-runner.outputs.container-name }}"
          
          echo "Deleting container instance: $CONTAINER_GROUP_NAME"
          az container delete \
            --resource-group $RESOURCE_GROUP \
            --name $CONTAINER_GROUP_NAME \
            --yes || true
          
          # Managed Identityを削除
          IDENTITY_NAME="id-aci-runner-${GITHUB_RUN_ID}"
          echo "Deleting User Assigned Managed Identity: $IDENTITY_NAME"
          az identity delete \
            --name $IDENTITY_NAME \
            --resource-group $RESOURCE_GROUP || true
          
          # 7日以上前の古いACIをクリーンアップ
          echo "Cleaning up old container instances (>7 days)..."
          CUTOFF_DATE=$(date -u -d '7 days ago' '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date -u -v-7d '+%Y-%m-%dT%H:%M:%SZ')
          
          OLD_CONTAINERS=$(az container list \
            --resource-group $RESOURCE_GROUP \
            --query "[?starts_with(name, 'aci-runner-') && properties.instanceView.state != 'Running'].{name:name, created:properties.instanceView.events[0].lastTimestamp}" \
            -o json | jq -r ".[] | select(.created < \"$CUTOFF_DATE\") | .name")
          
          if [ -n "$OLD_CONTAINERS" ]; then
            echo "Found old containers to delete:"
            echo "$OLD_CONTAINERS"
            for container in $OLD_CONTAINERS; do
              echo "Deleting $container..."
              az container delete --resource-group $RESOURCE_GROUP --name $container --yes || true
            done
          else
            echo "No old containers to clean up"
          fi
